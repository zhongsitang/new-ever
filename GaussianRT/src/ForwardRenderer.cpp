#include "gaussian_rt/ForwardRenderer.h"

#include <cuda_runtime.h>
#include <optix.h>
#include <optix_stubs.h>
#include <optix_function_table_definition.h>

#include <fstream>
#include <sstream>
#include <vector>

namespace gaussian_rt {

//------------------------------------------------------------------------------
// Error checking macros
//------------------------------------------------------------------------------

#define OPTIX_CHECK(call)                                                      \
    do {                                                                       \
        OptixResult res = call;                                                \
        if (res != OPTIX_SUCCESS) {                                            \
            fprintf(stderr, "OptiX error at %s:%d: %s\n", __FILE__, __LINE__,  \
                    optixGetErrorString(res));                                 \
            return Result::ErrorPipelineCreation;                              \
        }                                                                      \
    } while (0)

#define CUDA_CHECK(call)                                                       \
    do {                                                                       \
        cudaError_t err = call;                                                \
        if (err != cudaSuccess) {                                              \
            fprintf(stderr, "CUDA error at %s:%d: %s\n", __FILE__, __LINE__,   \
                    cudaGetErrorString(err));                                  \
            return Result::ErrorCUDA;                                          \
        }                                                                      \
    } while (0)

//------------------------------------------------------------------------------
// Shader Binding Table record types
//------------------------------------------------------------------------------

template <typename T>
struct alignas(OPTIX_SBT_RECORD_ALIGNMENT) SbtRecord {
    char header[OPTIX_SBT_RECORD_HEADER_SIZE];
    T data;
};

struct RayGenData {
    // Empty for now - data passed via params
};

struct MissData {
    float3 backgroundColor;
};

struct HitGroupData {
    // Primitive data pointers
    void* means;
    void* scales;
    void* quats;
    void* densities;
    void* features;
    uint32_t featureSize;
    uint32_t shDegree;
};

using RayGenRecord = SbtRecord<RayGenData>;
using MissRecord = SbtRecord<MissData>;
using HitGroupRecord = SbtRecord<HitGroupData>;

//------------------------------------------------------------------------------
// Launch parameters (shared with shaders)
//------------------------------------------------------------------------------

struct LaunchParams {
    // Output
    float4* colorOutput;
    VolumeIntegrationState* stateOutput;  // Per-ray integration state for backward pass
    int* triCollection;
    uint32_t* itersOutput;
    float4* lastDirac;

    // Input rays
    float3* rayOrigins;
    float3* rayDirections;
    uint32_t numRays;

    // Primitives
    float3* means;
    float3* scales;
    float4* quats;
    float* densities;
    float* features;
    uint32_t numPrimitives;
    uint32_t featureSize;

    // Render parameters
    float tmin;
    float tmax;
    uint32_t maxIters;
    uint32_t shDegree;
    float maxPrimSize;

    // Acceleration structure
    OptixTraversableHandle traversable;
};

//------------------------------------------------------------------------------
// External OptiX context
//------------------------------------------------------------------------------

extern OptixDeviceContext g_optixContext;

//------------------------------------------------------------------------------
// Embedded shader bytecode (generated by CMake)
//------------------------------------------------------------------------------

#if __has_include("forward_shaders.h")
#include "forward_shaders.h"
#else
// Placeholder if shaders not compiled yet
static const uint8_t forward_shaders_data[] = {};
static const size_t forward_shaders_size = 0;
#endif

//------------------------------------------------------------------------------
// ForwardRenderer implementation
//------------------------------------------------------------------------------

ForwardRenderer::ForwardRenderer(Device& device)
    : m_device(device) {
}

ForwardRenderer::~ForwardRenderer() {
    freePipeline();
}

Result ForwardRenderer::initialize(bool enableBackward, const char* shaderPath) {
    if (m_initialized) {
        return Result::Success;
    }

    m_enableBackward = enableBackward;

    // Create pipeline
    Result result = createPipeline(shaderPath);
    if (result != Result::Success) {
        return result;
    }

    // Create shader binding table
    result = createShaderTable();
    if (result != Result::Success) {
        return result;
    }

    // Allocate uniform buffer
    m_uniformBuffer = m_device.createBuffer(sizeof(LaunchParams));
    if (!m_uniformBuffer) {
        return Result::ErrorOutOfMemory;
    }

    m_initialized = true;
    return Result::Success;
}

Result ForwardRenderer::createPipeline(const char* shaderPath) {
    // Module compile options
    OptixModuleCompileOptions moduleCompileOptions = {};
    moduleCompileOptions.maxRegisterCount = OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT;
#ifdef NDEBUG
    moduleCompileOptions.optLevel = OPTIX_COMPILE_OPTIMIZATION_LEVEL_3;
    moduleCompileOptions.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_NONE;
#else
    moduleCompileOptions.optLevel = OPTIX_COMPILE_OPTIMIZATION_LEVEL_0;
    moduleCompileOptions.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_FULL;
#endif

    // Pipeline compile options
    OptixPipelineCompileOptions pipelineCompileOptions = {};
    pipelineCompileOptions.usesMotionBlur = false;
    pipelineCompileOptions.traversableGraphFlags = OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS;
    pipelineCompileOptions.numPayloadValues = 8;  // VolumeIntegrationState + hit buffer
    pipelineCompileOptions.numAttributeValues = 2;
    pipelineCompileOptions.exceptionFlags = OPTIX_EXCEPTION_FLAG_NONE;
    pipelineCompileOptions.pipelineLaunchParamsVariableName = "params";
    pipelineCompileOptions.usesPrimitiveTypeFlags = OPTIX_PRIMITIVE_TYPE_FLAGS_CUSTOM;

    // Load or use embedded shader
    std::vector<char> shaderCode;

    if (shaderPath) {
        std::string ptxPath = std::string(shaderPath) + "/forward_shaders.ptx";
        std::ifstream file(ptxPath, std::ios::binary);
        if (file) {
            file.seekg(0, std::ios::end);
            size_t size = file.tellg();
            file.seekg(0, std::ios::beg);
            shaderCode.resize(size);
            file.read(shaderCode.data(), size);
        }
    }

    // Use embedded shader if no external file
    const char* ptxData = nullptr;
    size_t ptxSize = 0;

    if (!shaderCode.empty()) {
        ptxData = shaderCode.data();
        ptxSize = shaderCode.size();
    } else if (forward_shaders_size > 0) {
        ptxData = reinterpret_cast<const char*>(forward_shaders_data);
        ptxSize = forward_shaders_size;
    } else {
        fprintf(stderr, "No shader code available\n");
        return Result::ErrorShaderCompilation;
    }

    // Create module
    char log[2048];
    size_t logSize = sizeof(log);
    OptixModule module;

    OptixResult res = optixModuleCreate(
        g_optixContext,
        &moduleCompileOptions,
        &pipelineCompileOptions,
        ptxData,
        ptxSize,
        log,
        &logSize,
        &module
    );

    if (res != OPTIX_SUCCESS) {
        fprintf(stderr, "OptiX module creation failed: %s\n", log);
        return Result::ErrorShaderCompilation;
    }

    // Create program groups
    OptixProgramGroupOptions pgOptions = {};

    // Ray generation program
    OptixProgramGroupDesc raygenDesc = {};
    raygenDesc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;
    raygenDesc.raygen.module = module;
    raygenDesc.raygen.entryFunctionName = "__raygen__main";

    OptixProgramGroup raygenPG;
    logSize = sizeof(log);
    OPTIX_CHECK(optixProgramGroupCreate(
        g_optixContext,
        &raygenDesc,
        1,
        &pgOptions,
        log,
        &logSize,
        &raygenPG
    ));

    // Miss program
    OptixProgramGroupDesc missDesc = {};
    missDesc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
    missDesc.miss.module = module;
    missDesc.miss.entryFunctionName = "__miss__main";

    OptixProgramGroup missPG;
    logSize = sizeof(log);
    OPTIX_CHECK(optixProgramGroupCreate(
        g_optixContext,
        &missDesc,
        1,
        &pgOptions,
        log,
        &logSize,
        &missPG
    ));

    // Hit group (intersection + anyhit)
    OptixProgramGroupDesc hitgroupDesc = {};
    hitgroupDesc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
    hitgroupDesc.hitgroup.moduleIS = module;
    hitgroupDesc.hitgroup.entryFunctionNameIS = "__intersection__ellipsoid";
    hitgroupDesc.hitgroup.moduleAH = module;
    hitgroupDesc.hitgroup.entryFunctionNameAH = "__anyhit__sorting";
    hitgroupDesc.hitgroup.moduleCH = nullptr;
    hitgroupDesc.hitgroup.entryFunctionNameCH = nullptr;

    OptixProgramGroup hitgroupPG;
    logSize = sizeof(log);
    OPTIX_CHECK(optixProgramGroupCreate(
        g_optixContext,
        &hitgroupDesc,
        1,
        &pgOptions,
        log,
        &logSize,
        &hitgroupPG
    ));

    // Create pipeline
    OptixProgramGroup programGroups[] = { raygenPG, missPG, hitgroupPG };

    OptixPipelineLinkOptions linkOptions = {};
    linkOptions.maxTraceDepth = 1;

    OptixPipeline pipeline;
    logSize = sizeof(log);
    OPTIX_CHECK(optixPipelineCreate(
        g_optixContext,
        &pipelineCompileOptions,
        &linkOptions,
        programGroups,
        3,
        log,
        &logSize,
        &pipeline
    ));

    // Set stack sizes
    OptixStackSizes stackSizes = {};
    for (auto& pg : programGroups) {
        optixUtilAccumulateStackSizes(pg, &stackSizes, pipeline);
    }

    uint32_t directCallableStackSizeFromTraversal = 0;
    uint32_t directCallableStackSizeFromState = 0;
    uint32_t continuationStackSize = 0;

    optixUtilComputeStackSizes(
        &stackSizes,
        1,  // maxTraceDepth
        0,  // maxCCDepth
        0,  // maxDCDepth
        &directCallableStackSizeFromTraversal,
        &directCallableStackSizeFromState,
        &continuationStackSize
    );

    OPTIX_CHECK(optixPipelineSetStackSize(
        pipeline,
        directCallableStackSizeFromTraversal,
        directCallableStackSizeFromState,
        continuationStackSize,
        1  // maxTraversableGraphDepth
    ));

    m_pipeline = pipeline;

    // Store program groups for SBT creation
    m_raygenRecord = reinterpret_cast<void*>(raygenPG);
    m_missRecord = reinterpret_cast<void*>(missPG);
    m_hitgroupRecord = reinterpret_cast<void*>(hitgroupPG);

    return Result::Success;
}

Result ForwardRenderer::createShaderTable() {
    // Raygen record
    RayGenRecord raygenRecord;
    OPTIX_CHECK(optixSbtRecordPackHeader(
        reinterpret_cast<OptixProgramGroup>(m_raygenRecord),
        &raygenRecord
    ));

    void* d_raygen = m_device.createBuffer(sizeof(RayGenRecord), &raygenRecord);
    if (!d_raygen) return Result::ErrorOutOfMemory;

    // Miss record
    MissRecord missRecord;
    missRecord.data.backgroundColor = make_float3(0.0f, 0.0f, 0.0f);
    OPTIX_CHECK(optixSbtRecordPackHeader(
        reinterpret_cast<OptixProgramGroup>(m_missRecord),
        &missRecord
    ));

    void* d_miss = m_device.createBuffer(sizeof(MissRecord), &missRecord);
    if (!d_miss) return Result::ErrorOutOfMemory;

    // Hitgroup record
    HitGroupRecord hitgroupRecord;
    memset(&hitgroupRecord.data, 0, sizeof(HitGroupData));
    OPTIX_CHECK(optixSbtRecordPackHeader(
        reinterpret_cast<OptixProgramGroup>(m_hitgroupRecord),
        &hitgroupRecord
    ));

    void* d_hitgroup = m_device.createBuffer(sizeof(HitGroupRecord), &hitgroupRecord);
    if (!d_hitgroup) return Result::ErrorOutOfMemory;

    // Store SBT buffers
    m_raygenRecord = d_raygen;
    m_missRecord = d_miss;
    m_hitgroupRecord = d_hitgroup;

    return Result::Success;
}

void ForwardRenderer::freePipeline() {
    if (m_pipeline) {
        optixPipelineDestroy(reinterpret_cast<OptixPipeline>(m_pipeline));
        m_pipeline = nullptr;
    }

    if (m_raygenRecord) m_device.freeBuffer(m_raygenRecord);
    if (m_missRecord) m_device.freeBuffer(m_missRecord);
    if (m_hitgroupRecord) m_device.freeBuffer(m_hitgroupRecord);
    if (m_uniformBuffer) m_device.freeBuffer(m_uniformBuffer);

    m_raygenRecord = nullptr;
    m_missRecord = nullptr;
    m_hitgroupRecord = nullptr;
    m_uniformBuffer = nullptr;
    m_initialized = false;
}

Result ForwardRenderer::allocateOutput(size_t numRays, size_t maxIters, ForwardOutput& output) {
    output.numRays = numRays;
    output.maxIters = maxIters;

    // Color output (float4 * numRays)
    output.d_color = m_device.createBuffer(numRays * sizeof(float) * 4);
    if (!output.d_color) return Result::ErrorOutOfMemory;

    // State output (VolumeIntegrationState * numRays) - for backward pass gradient computation
    if (m_enableBackward) {
        output.d_state = m_device.createBuffer(numRays * sizeof(VolumeIntegrationState));
        if (!output.d_state) return Result::ErrorOutOfMemory;

        // Triangle collection (int * numRays * maxIters)
        output.d_triCollection = m_device.createBuffer(numRays * maxIters * sizeof(int));
        if (!output.d_triCollection) return Result::ErrorOutOfMemory;

        // Iterations per ray (uint * numRays)
        output.d_iters = m_device.createBuffer(numRays * sizeof(uint32_t));
        if (!output.d_iters) return Result::ErrorOutOfMemory;
    }

    return Result::Success;
}

void ForwardRenderer::freeOutput(ForwardOutput& output) {
    if (output.d_color) m_device.freeBuffer(output.d_color);
    if (output.d_state) m_device.freeBuffer(output.d_state);
    if (output.d_triCollection) m_device.freeBuffer(output.d_triCollection);
    if (output.d_iters) m_device.freeBuffer(output.d_iters);

    output.d_color = nullptr;
    output.d_state = nullptr;
    output.d_triCollection = nullptr;
    output.d_iters = nullptr;
}

Result ForwardRenderer::traceRays(
    const AccelStruct& accel,
    const GaussianPrimitives& primitives,
    void* d_rayOrigins,
    void* d_rayDirections,
    size_t numRays,
    const RenderParams& params,
    ForwardOutput& output) {

    if (!m_initialized || !accel.isValid() || !primitives.isValid()) {
        return Result::ErrorInvalidArgument;
    }

    // Setup launch parameters
    LaunchParams launchParams = {};

    // Output buffers
    launchParams.colorOutput = static_cast<float4*>(output.d_color);
    launchParams.stateOutput = static_cast<VolumeIntegrationState*>(output.d_state);
    launchParams.triCollection = static_cast<int*>(output.d_triCollection);
    launchParams.itersOutput = static_cast<uint32_t*>(output.d_iters);

    // Input rays
    launchParams.rayOrigins = static_cast<float3*>(d_rayOrigins);
    launchParams.rayDirections = static_cast<float3*>(d_rayDirections);
    launchParams.numRays = static_cast<uint32_t>(numRays);

    // Primitives
    launchParams.means = static_cast<float3*>(primitives.getMeansDevice());
    launchParams.scales = static_cast<float3*>(primitives.getScalesDevice());
    launchParams.quats = static_cast<float4*>(primitives.getQuatsDevice());
    launchParams.densities = static_cast<float*>(primitives.getDensitiesDevice());
    launchParams.features = static_cast<float*>(primitives.getFeaturesDevice());
    launchParams.numPrimitives = static_cast<uint32_t>(primitives.getNumPrimitives());
    launchParams.featureSize = static_cast<uint32_t>(primitives.getFeatureSize());

    // Render parameters
    launchParams.tmin = params.tmin;
    launchParams.tmax = params.tmax;
    launchParams.maxIters = params.maxIters;
    launchParams.shDegree = params.shDegree;
    launchParams.maxPrimSize = params.maxPrimSize;

    // Acceleration structure
    launchParams.traversable = reinterpret_cast<OptixTraversableHandle>(accel.getTraversableHandle());

    // Upload parameters
    CUDA_CHECK(cudaMemcpyAsync(
        m_uniformBuffer,
        &launchParams,
        sizeof(LaunchParams),
        cudaMemcpyHostToDevice,
        static_cast<cudaStream_t>(m_device.getCudaStream())
    ));

    // Setup SBT
    OptixShaderBindingTable sbt = {};
    sbt.raygenRecord = reinterpret_cast<CUdeviceptr>(m_raygenRecord);
    sbt.missRecordBase = reinterpret_cast<CUdeviceptr>(m_missRecord);
    sbt.missRecordStrideInBytes = sizeof(MissRecord);
    sbt.missRecordCount = 1;
    sbt.hitgroupRecordBase = reinterpret_cast<CUdeviceptr>(m_hitgroupRecord);
    sbt.hitgroupRecordStrideInBytes = sizeof(HitGroupRecord);
    sbt.hitgroupRecordCount = 1;

    // Launch
    OPTIX_CHECK(optixLaunch(
        reinterpret_cast<OptixPipeline>(m_pipeline),
        static_cast<CUstream>(m_device.getCudaStream()),
        reinterpret_cast<CUdeviceptr>(m_uniformBuffer),
        sizeof(LaunchParams),
        &sbt,
        static_cast<unsigned int>(numRays),
        1,
        1
    ));

    // Synchronize
    CUDA_CHECK(cudaStreamSynchronize(static_cast<cudaStream_t>(m_device.getCudaStream())));

    return Result::Success;
}

} // namespace gaussian_rt
