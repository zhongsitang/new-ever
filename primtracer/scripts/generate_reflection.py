#!/usr/bin/env python3
"""
Generate Slang reflection data for launch parameters.

Usage:
    python generate_reflection.py slang/optix_shaders.slang -o src/params_reflection.h

This script:
1. Compiles the Slang shader with reflection output
2. Extracts global parameter layout information
3. Generates a C++ header with embedded JSON
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path


def run_slang_reflection(slang_file: Path, include_dirs: list[Path]) -> dict:
    """Run slangc to get reflection JSON."""
    cmd = [
        "slangc",
        str(slang_file),
        "-target", "cuda",  # or optix
        "-dump-reflection-json",
        "-o", "/dev/null",
    ]
    for inc in include_dirs:
        cmd.extend(["-I", str(inc)])

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        print(f"slangc failed: {result.stderr}", file=sys.stderr)
        sys.exit(1)

    # Parse the reflection JSON from stdout
    return json.loads(result.stdout)


def extract_global_params(reflection: dict) -> dict:
    """Extract global parameter layout from reflection data."""
    # Navigate Slang reflection structure to find SLANG_globalParams
    for entry_point in reflection.get("entryPoints", []):
        for param in entry_point.get("parameters", []):
            if param.get("name") == "SLANG_globalParams":
                return extract_type_layout(param)

    # Also check global scope
    for param in reflection.get("parameters", []):
        return extract_type_layout(param)

    raise ValueError("Could not find global parameters in reflection")


def extract_type_layout(param: dict) -> dict:
    """Extract field layout from a type."""
    layout = {
        "size": param.get("size", 0),
        "alignment": param.get("alignment", 1),
        "fields": []
    }

    for field in param.get("fields", []):
        layout["fields"].append({
            "name": field["name"],
            "offset": field.get("offset", 0),
            "size": field.get("size", 0),
            "alignment": field.get("alignment", 1),
            "type": field.get("type", {}).get("name", "unknown"),
        })

    return layout


def generate_header(layout: dict, output_path: Path):
    """Generate C++ header with embedded reflection JSON."""
    json_str = json.dumps(layout, indent=2)
    # Escape for C++ raw string
    escaped = json_str.replace("\\", "\\\\").replace('"', '\\"')

    header = f'''// Auto-generated by generate_reflection.py - DO NOT EDIT
#pragma once

namespace params_reflection {{

inline const char* const kGlobalParamsJson = R"JSON(
{json_str}
)JSON";

constexpr size_t kGlobalParamsSize = {layout["size"]};
constexpr size_t kGlobalParamsAlignment = {layout["alignment"]};

}} // namespace params_reflection
'''
    output_path.write_text(header)
    print(f"Generated: {output_path}")


def main():
    parser = argparse.ArgumentParser(description="Generate Slang reflection header")
    parser.add_argument("slang_file", type=Path, help="Input Slang file")
    parser.add_argument("-o", "--output", type=Path, required=True,
                        help="Output C++ header file")
    parser.add_argument("-I", "--include", type=Path, action="append", default=[],
                        help="Include directories")
    args = parser.parse_args()

    reflection = run_slang_reflection(args.slang_file, args.include)
    layout = extract_global_params(reflection)
    generate_header(layout, args.output)


if __name__ == "__main__":
    main()
