// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <cuda_runtime.h>
#include <optix.h>

#include <cstdint>
#include <cstring>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

// =============================================================================
// LaunchParams - Reflection-based OptiX launch parameter builder
// =============================================================================
//
// This class uses Slang reflection data to dynamically build launch parameters
// without requiring manual C++ struct definitions or padding calculations.
//
// Usage:
//   LaunchParams params(reflection_json);
//   params.set("image", StructuredBuffer<float4>{ptr, size});
//   params.set("tmin", 0.1f);
//   params.set("handle", accel_handle);
//   params.upload();
//   optixLaunch(..., params.device_ptr(), params.size(), ...);
//
// =============================================================================

/// Field metadata from Slang reflection
struct FieldInfo {
    std::string name;
    std::string type;
    size_t offset;
    size_t size;
    size_t alignment;
};

/// Slang StructuredBuffer layout (must match Slang's RWStructuredBuffer)
template <typename T>
struct StructuredBuffer {
    T* data;
    uint64_t size;
};

/// Reflection-based launch parameter builder
class LaunchParams {
public:
    /// Construct from embedded reflection data (parsed at init time)
    explicit LaunchParams(const char* reflection_json);

    ~LaunchParams() {
        if (d_params_) cudaFree(reinterpret_cast<void*>(d_params_));
    }

    // Non-copyable
    LaunchParams(const LaunchParams&) = delete;
    LaunchParams& operator=(const LaunchParams&) = delete;

    /// Set a field by name (type-safe)
    template <typename T>
    void set(const std::string& name, const T& value) {
        auto it = fields_.find(name);
        if (it == fields_.end()) {
            throw std::runtime_error("Unknown field: " + name);
        }
        const auto& field = it->second;
        if (sizeof(T) != field.size) {
            throw std::runtime_error("Size mismatch for field: " + name +
                " (expected " + std::to_string(field.size) +
                ", got " + std::to_string(sizeof(T)) + ")");
        }
        std::memcpy(buffer_.data() + field.offset, &value, sizeof(T));
    }

    /// Upload to device memory
    void upload() {
        if (!d_params_) {
            cudaMalloc(reinterpret_cast<void**>(&d_params_), buffer_.size());
        }
        cudaMemcpy(reinterpret_cast<void*>(d_params_), buffer_.data(),
                   buffer_.size(), cudaMemcpyHostToDevice);
    }

    /// Get device pointer for optixLaunch
    CUdeviceptr device_ptr() const { return d_params_; }

    /// Get total size of params
    size_t size() const { return buffer_.size(); }

    /// Check if a field exists
    bool has_field(const std::string& name) const {
        return fields_.find(name) != fields_.end();
    }

    /// Get field info (for debugging/validation)
    const FieldInfo& field_info(const std::string& name) const {
        auto it = fields_.find(name);
        if (it == fields_.end()) {
            throw std::runtime_error("Unknown field: " + name);
        }
        return it->second;
    }

    /// Validate C++ struct layout against reflection (compile-time check helper)
    template <typename CppStruct>
    void validate_layout() const {
        if (sizeof(CppStruct) != buffer_.size()) {
            throw std::runtime_error(
                "Struct size mismatch: C++=" + std::to_string(sizeof(CppStruct)) +
                " Slang=" + std::to_string(buffer_.size()));
        }
    }

private:
    void parse_reflection(const char* json);

    std::unordered_map<std::string, FieldInfo> fields_;
    std::vector<uint8_t> buffer_;
    CUdeviceptr d_params_ = 0;
};

// =============================================================================
// Embedded Reflection Data
// =============================================================================
//
// Generated by: slangc -target optix -emit-reflection-json
// The reflection JSON is embedded at compile time via #include
//
// Format (simplified):
// {
//   "globalParams": {
//     "size": 400,
//     "alignment": 16,
//     "fields": [
//       {"name": "image", "offset": 0, "size": 16, "type": "StructuredBuffer<float4>"},
//       {"name": "tmin", "offset": 336, "size": 4, "type": "float"},
//       ...
//     ]
//   }
// }
//
// =============================================================================
