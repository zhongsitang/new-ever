#!/usr/bin/env python3
# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generate optix-intrinsics.slang with OptiX intrinsic wrappers for Slang."""

NUM_PAYLOADS = 32
NUM_ATTRIBUTES = 8


def generate():
    lines = [
        "// Generated by gen_optix_util.py - do not edit manually",
        "",
        "// -----------------------------------------------------------------------------",
        "// Hit kind",
        "// -----------------------------------------------------------------------------",
        "uint optixGetHitKind() { __intrinsic_asm \"optixGetHitKind()\"; }",
        "",
        "// -----------------------------------------------------------------------------",
        "// Payload accessors (0-31)",
        "// -----------------------------------------------------------------------------",
    ]

    # Individual payload getters/setters
    for i in range(NUM_PAYLOADS):
        lines.append(f"void set_payload{i}(uint v) {{ __intrinsic_asm \"optixSetPayload_{i}($0)\"; }}")
        lines.append(f"uint get_payload{i}() {{ __intrinsic_asm \"optixGetPayload_{i}()\"; }}")

    # Generic payload accessor via switch
    lines.extend([
        "",
        "[ForceInline]",
        "void set_payload(uint i, uint val) {",
        "    switch (i) {",
    ])
    for i in range(NUM_PAYLOADS):
        lines.append(f"    case {i}: return set_payload{i}(val);")
    lines.extend([
        "    }",
        "}",
        "",
        "[ForceInline]",
        "uint get_payload(uint i) {",
        "    switch (i) {",
    ])
    for i in range(NUM_PAYLOADS):
        lines.append(f"    case {i}: return get_payload{i}();")
    lines.extend([
        "    }",
        "}",
        "",
        "// -----------------------------------------------------------------------------",
        "// Attribute accessors (0-7)",
        "// -----------------------------------------------------------------------------",
    ])

    # Attribute getters
    for i in range(NUM_ATTRIBUTES):
        lines.append(f"uint optixGetAttribute_{i}() {{ __intrinsic_asm \"optixGetAttribute_{i}()\"; }}")

    lines.extend([
        "",
        "// -----------------------------------------------------------------------------",
        "// Report hit with attributes (1-8 attributes)",
        "// -----------------------------------------------------------------------------",
    ])

    # ReportHit overloads
    for n in range(1, NUM_ATTRIBUTES + 1):
        args = ", ".join([f"in uint p{i}" for i in range(n)])
        asm_args = ", ".join([f"${i+2}" for i in range(n)])
        lines.append(f"bool optixReportHit(float t, uint hitKind, {args}) {{ __intrinsic_asm \"optixReportIntersection($0, $1, {asm_args})\"; }}")

    lines.extend([
        "",
        "// -----------------------------------------------------------------------------",
        "// Trace with payload array (0-32 payloads)",
        "// -----------------------------------------------------------------------------",
    ])

    # optixTraceP variants with inout array
    for n in range(NUM_PAYLOADS + 1):
        if n == 0:
            init = ""
            finish = ""
            arg_list = ""
        else:
            arg_list = ", ".join([f"p{i}" for i in range(n)])
            init = "\n".join([f"    p{i} = (*$5)[{i}];" for i in range(n)])
            finish = "\n".join([f"    (*$5)[{i}] = p{i};" for i in range(n)])

        lines.append(f"""
void optixTraceP{n}(
    in RaytracingAccelerationStructure handle,
    in float3 ray_origin,
    in float3 ray_direction,
    in float tmin,
    in float tmax,
    inout uint[{n}] payload)
{{
  __intrinsic_asm R"(
  uint {arg_list};
  {init}
    optixTrace(
        $0, $1, $2, $3, $4,
        0.0f, OptixVisibilityMask(255), OPTIX_RAY_FLAG_NONE,
        0, 0, 0{', ' + arg_list if arg_list else ''});
  {finish}
  )";
}}""")

    lines.extend([
        "",
        "// -----------------------------------------------------------------------------",
        "// Trace with individual payload arguments (0-31)",
        "// -----------------------------------------------------------------------------",
    ])

    # optixTrace variants with individual args
    for n in range(NUM_PAYLOADS):
        if n == 0:
            fn_args = ""
            trace_args = ""
        else:
            fn_args = ",\n    ".join([f"in uint p{i}" for i in range(n)])
            trace_args = ", " + ", ".join([f"${i+5}" for i in range(n)])

        lines.append(f"""
void optixTrace{n}(
    in RaytracingAccelerationStructure handle,
    in float3 ray_origin,
    in float3 ray_direction,
    in float tmin,
    in float tmax{', ' + fn_args if fn_args else ''})
{{
  __intrinsic_asm R"(
    optixTrace(
        $0, $1, $2, $3, $4,
        0.0f, OptixVisibilityMask(255), OPTIX_RAY_FLAG_NONE,
        0, 0, 0{trace_args});
  )";
}}""")

    return "\n".join(lines)


if __name__ == "__main__":
    content = generate()
    with open("optix-intrinsics.slang", "w") as f:
        f.write(content)
    print(f"Generated optix-intrinsics.slang ({len(content)} bytes)")
