# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Generate OptiX intrinsics for Slang targeting CUDA/OptiX 9.1.

Modern Slang (2025+) has built-in support for many OptiX intrinsics through
standard HLSL ray tracing semantics. However, for custom intersection shaders
and multi-payload trace operations, we still need some wrappers.

This script generates optix-intrinsics.slang with:
1. Payload getter/setter functions for 32 registers
2. Attribute getter functions for up to 8 attributes
3. optixReportHit variants for custom intersection shaders
4. optixTrace variants with explicit payload count (for array-based payload)
"""

# Header with documentation
util = """// Generated by gen_optix_util.py
// OptiX 9.1 compatible intrinsics for Slang -> CUDA compilation
//
// Modern Slang provides built-in ray tracing intrinsics via HLSL semantics:
//   PrimitiveIndex()      -> optixGetPrimitiveIndex()
//   InstanceIndex()       -> optixGetInstanceIndex()
//   InstanceID()          -> optixGetInstanceId()
//   WorldRayOrigin()      -> optixGetWorldRayOrigin()
//   WorldRayDirection()   -> optixGetWorldRayDirection()
//   ObjectRayOrigin()     -> optixGetObjectRayOrigin()
//   ObjectRayDirection()  -> optixGetObjectRayDirection()
//   RayTMin()             -> optixGetRayTmin()
//   RayTCurrent()         -> optixGetRayTmax()
//   HitKind()             -> optixGetHitKind()
//   IgnoreHit()           -> optixIgnoreIntersection()
//   AcceptHitAndEndSearch() -> optixTerminateRay()
//   DispatchRaysIndex()   -> optixGetLaunchIndex()
//   DispatchRaysDimensions() -> optixGetLaunchDimensions()
//
// This file provides additional functions for:
//   - Direct payload register access (get_payload/set_payload)
//   - Custom intersection reporting (optixReportHit)
//   - Multi-payload trace operations (optixTraceP<N>)
//   - Attribute access in anyhit/closesthit shaders

// ============================================================================
// Payload Register Access (32 registers)
// ============================================================================

"""

# Generate individual payload getter/setter functions
for n in range(32):
    util += f"""
[ForceInline]
void __setPayload_{n}(uint v) {{
    __target_switch {{
        case cuda: __intrinsic_asm "optixSetPayload_{n}($0)";
    }}
}}

[ForceInline]
uint __getPayload_{n}() {{
    __target_switch {{
        case cuda: __intrinsic_asm "optixGetPayload_{n}()";
    }}
}}
"""

# Generate unified set_payload function with switch
util += """
// ============================================================================
// Unified Payload Access Functions
// ============================================================================

/// Set payload register by index (0-31)
[ForceInline]
void set_payload(uint i, uint val) {
    switch (i) {
"""

for n in range(32):
    util += f"""        case {n}: __setPayload_{n}(val); break;
"""

util += """    }
}

/// Get payload register by index (0-31)
[ForceInline]
uint get_payload(uint i) {
    switch (i) {
"""

for n in range(32):
    util += f"""        case {n}: return __getPayload_{n}();
"""

util += """    }
    return 0; // Unreachable
}

// ============================================================================
// Attribute Access Functions (8 attributes max)
// ============================================================================

"""

# Generate attribute getters
for n in range(8):
    util += f"""
/// Get attribute {n} from intersection shader
[ForceInline]
uint optixGetAttribute_{n}() {{
    __target_switch {{
        case cuda: __intrinsic_asm "optixGetAttribute_{n}()";
    }}
}}
"""

# Generate optixReportHit variants
util += """
// ============================================================================
// Custom Intersection Reporting
// ============================================================================

"""

for n in range(8):
    fn_args = ", ".join([f"uint a{i}" for i in range(n+1)])
    asm_args = ', '.join([f"${i+2}" for i in range(n+1)])
    util += f"""
/// Report intersection with {n+1} attribute(s)
[ForceInline]
bool optixReportHit(float t, uint hitKind, {fn_args}) {{
    __target_switch {{
        case cuda: __intrinsic_asm "optixReportIntersection($0, $1, {asm_args})";
    }}
}}
"""

# Generate optixTrace variants with payload arrays
util += """
// ============================================================================
// Multi-Payload Trace Operations
// ============================================================================
// These functions trace rays with explicit payload arrays.
// The payload is passed by reference and updated in-place.

"""

for n in range(1, 33):  # 1 to 32 payloads
    # Generate the argument list for uint variables
    arg_list = ", ".join([f"p{i}" for i in range(n)])

    # Generate initialization from array
    init_list = "\n    ".join([f"p{i} = (*$5)[{i}];" for i in range(n)])

    # Generate copy back to array
    finish_list = "\n    ".join([f"(*$5)[{i}] = p{i};" for i in range(n)])

    util += f"""
/// Trace ray with {n} payload register(s), using array interface
[ForceInline]
void optixTraceP{n}(
    RaytracingAccelerationStructure handle,
    float3 ray_origin,
    float3 ray_direction,
    float tmin,
    float tmax,
    inout uint[{n}] payload
) {{
    __target_switch {{
        case cuda: __intrinsic_asm R"(
    uint {arg_list};
    {init_list}
    optixTrace(
        $0,
        $1,
        $2,
        $3,
        $4,
        0.0f,                // rayTime
        OptixVisibilityMask( 255 ),
        OPTIX_RAY_FLAG_NONE,
        0,                   // SBT offset
        0,                   // SBT stride
        0,                   // missSBTIndex
        {arg_list});
    {finish_list}
    )";
    }}
}}
"""

# Also generate variants with explicit payload arguments (not arrays)
util += """
// ============================================================================
// Alternative Trace Operations (explicit payload arguments)
// ============================================================================
// These are useful when you have individual payload variables.

"""

for n in range(1, 17):  # Up to 16 individual payload args
    fn_args = ",\n    ".join([f"inout uint p{i}" for i in range(n)])
    asm_args = ", ".join([f"${i+5}" for i in range(n)])

    util += f"""
/// Trace ray with {n} explicit payload argument(s)
[ForceInline]
void optixTrace{n}(
    RaytracingAccelerationStructure handle,
    float3 ray_origin,
    float3 ray_direction,
    float tmin,
    float tmax,
    {fn_args}
) {{
    __target_switch {{
        case cuda: __intrinsic_asm R"(
    optixTrace(
        $0,
        $1,
        $2,
        $3,
        $4,
        0.0f,                // rayTime
        OptixVisibilityMask( 255 ),
        OPTIX_RAY_FLAG_NONE,
        0,                   // SBT offset
        0,                   // SBT stride
        0,                   // missSBTIndex
        {asm_args});
    )";
    }}
}}
"""

# Add HitKind getter using intrinsic (as backup)
util += """
// ============================================================================
// Additional OptiX Intrinsics
// ============================================================================

/// Get hit kind from intersection (backup for when HitKind() doesn't work)
[ForceInline]
uint optixGetHitKind() {
    __target_switch {
        case cuda: __intrinsic_asm "optixGetHitKind()";
    }
}

/// Get SBT data pointer (for advanced use cases)
[ForceInline]
uint64_t optixGetSbtDataPointer() {
    __target_switch {
        case cuda: __intrinsic_asm "optixGetSbtDataPointer()";
    }
}

/// Terminate ray traversal from anyhit shader
[ForceInline]
void optixTerminateRay() {
    __target_switch {
        case cuda: __intrinsic_asm "optixTerminateRay()";
    }
}

/// Ignore current intersection from anyhit shader
[ForceInline]
void optixIgnoreIntersection() {
    __target_switch {
        case cuda: __intrinsic_asm "optixIgnoreIntersection()";
    }
}
"""

# Write to file
with open("optix-intrinsics.slang", "w") as f:
    f.write(util)

print("Generated optix-intrinsics.slang successfully.")
