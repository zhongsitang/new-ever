// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file implements the autograd wrapper for the spline tracer.
// It includes the slang-generated CUDA code which provides TensorView, DualModel,
// and the backward kernels.

#include <cuda_runtime.h>
#include <ATen/cuda/CUDAContext.h>

// Include slang-generated CUDA code first (defines TensorView, DualModel, kernels)
// This file is generated by slangc from backwards_kernel_cuda.slang
#include "backwards_kernel.cu"

// Now include torch headers and our other headers
#include <torch/torch.h>
#include "Forward.h"
#include "GAS.h"
#include "structs.h"

// Helper to create TensorView from torch::Tensor
// Note: We don't use slang-torch-prelude.h because it also defines TensorView,
// which would conflict with the definition in the slang-generated code.
// This simple helper does the same thing as slang-torch-prelude.h's make_tensor_view.
static TensorView make_tensor_view(torch::Tensor t) {
    TensorView v = {};
    v.dimensionCount = t.dim();
    v.data = reinterpret_cast<uint8_t*>(t.data_ptr());

    size_t elem_size = t.element_size();
    for (int i = 0; i < t.dim() && i < kSlangTorchTensorMaxDim; ++i) {
        v.strides[i] = t.stride(i) * elem_size;
        v.sizes[i] = t.size(i);
    }
    return v;
}

// Kernel launcher implementations
static void launch_backwards_kernel(
    TensorView last_state,
    TensorView last_dirac,
    TensorView iters,
    TensorView tri_collection,
    TensorView ray_origins,
    TensorView ray_directions,
    DualModel model,
    TensorView initial_drgb,
    TensorView dL_dinital_drgb,
    TensorView touch_count,
    TensorView dL_doutputs,
    TensorView wcts,
    float tmin,
    float tmax,
    float max_prim_size,
    uint32_t max_iters,
    uint32_t num_rays,
    cudaStream_t stream
) {
    const int block_size = 16;
    dim3 blockDim(block_size, 1, 1);
    dim3 gridDim((num_rays + block_size - 1) / block_size, 1, 1);

    backwards_kernel<<<gridDim, blockDim, 0, stream>>>(
        last_state,
        last_dirac,
        iters,
        tri_collection,
        ray_origins,
        ray_directions,
        model,
        initial_drgb,
        dL_dinital_drgb,
        touch_count,
        dL_doutputs,
        wcts,
        tmin,
        tmax,
        max_prim_size,
        max_iters
    );
}

static void launch_backwards_initial_drgb_kernel(
    TensorView ray_origins,
    TensorView ray_directions,
    DualModel model,
    TensorView initial_drgb,
    TensorView initial_inds,
    TensorView dL_dinital_drgb,
    TensorView touch_count,
    float tmin,
    uint32_t num_rays,
    uint32_t num_inds,
    cudaStream_t stream
) {
    const int ray_block_size = 64;
    const int second_block_size = 16;
    dim3 blockDim(ray_block_size, second_block_size, 1);
    dim3 gridDim(
        (num_rays + ray_block_size - 1) / ray_block_size,
        (num_inds + second_block_size - 1) / second_block_size,
        1
    );

    backwards_initial_drgb_kernel<<<gridDim, blockDim, 0, stream>>>(
        ray_origins,
        ray_directions,
        model,
        initial_drgb,
        initial_inds,
        dL_dinital_drgb,
        touch_count,
        tmin
    );
}

// Parameters for the tracer
struct SplineTracerParams {
    float tmin = 0.0f;
    float tmax = 1000.0f;
    float max_prim_size = 3.0f;
    int max_iters = 500;
};

// Main autograd function
class SplineTracerFunction : public torch::autograd::Function<SplineTracerFunction> {
public:
    static std::vector<torch::Tensor> forward(
        torch::autograd::AutogradContext* ctx,
        torch::Tensor mean,
        torch::Tensor scale,
        torch::Tensor quat,
        torch::Tensor density,
        torch::Tensor features,
        torch::Tensor rayo,
        torch::Tensor rayd,
        torch::Tensor wcts,
        SplineTracerParams params,
        int64_t optix_context_ptr,
        int64_t gas_handle
    ) {
        auto device = rayo.device();
        const size_t num_rays = rayo.size(0);
        const size_t num_prims = mean.size(0);
        const size_t max_iters = params.max_iters;

        // Ensure contiguous
        mean = mean.contiguous();
        scale = scale.contiguous();
        quat = quat.contiguous();
        density = density.contiguous();
        features = features.contiguous();
        rayo = rayo.contiguous();
        rayd = rayd.contiguous();

        // Setup primitives
        Primitives prims = {};
        prims.means = reinterpret_cast<float3*>(mean.data_ptr());
        prims.scales = reinterpret_cast<float3*>(scale.data_ptr());
        prims.quats = reinterpret_cast<float4*>(quat.data_ptr());
        prims.densities = reinterpret_cast<float*>(density.data_ptr());
        prims.features = reinterpret_cast<float*>(features.data_ptr());
        prims.num_prims = num_prims;
        prims.feature_size = features.size(1);

        // Allocate outputs
        auto color = torch::zeros({(long)num_rays, 4}, torch::dtype(torch::kFloat32).device(device));
        auto tri_collection = torch::zeros({(long)(num_rays * max_iters)}, torch::dtype(torch::kInt32).device(device));
        auto initial_drgb = torch::zeros({(long)num_rays, 4}, torch::dtype(torch::kFloat32).device(device));
        auto initial_touch_count = torch::zeros({1}, torch::dtype(torch::kInt32).device(device));
        auto initial_touch_inds = torch::zeros({(long)num_prims}, torch::dtype(torch::kInt32).device(device));

        // Saved for backward
        const size_t num_float_per_state = sizeof(SplineState) / sizeof(float);
        auto states = torch::zeros({(long)num_rays, (long)num_float_per_state}, torch::dtype(torch::kFloat32).device(device));
        auto diracs = torch::zeros({(long)num_rays, 4}, torch::dtype(torch::kFloat32).device(device));
        auto iters_tensor = torch::zeros({(long)num_rays}, torch::dtype(torch::kInt32).device(device));
        auto touch_count = torch::zeros({(long)num_prims}, torch::dtype(torch::kInt32).device(device));

        // Get OptiX handles
        auto optix_ctx = reinterpret_cast<OptixDeviceContext>(optix_context_ptr);
        auto handle = static_cast<OptixTraversableHandle>(gas_handle);

        // Create Forward and run
        Forward forward(optix_ctx, device.index(), prims, true);
        uint sh_degree = static_cast<uint>(sqrt(prims.feature_size)) - 1;

        forward.trace_rays(
            handle,
            num_rays,
            reinterpret_cast<float3*>(rayo.data_ptr()),
            reinterpret_cast<float3*>(rayd.data_ptr()),
            color.data_ptr(),
            sh_degree,
            params.tmin, params.tmax,
            reinterpret_cast<float4*>(initial_drgb.data_ptr()),
            nullptr,
            max_iters,
            params.max_prim_size,
            reinterpret_cast<uint*>(iters_tensor.data_ptr()),
            nullptr,
            reinterpret_cast<uint*>(touch_count.data_ptr()),
            reinterpret_cast<float4*>(diracs.data_ptr()),
            reinterpret_cast<SplineState*>(states.data_ptr()),
            reinterpret_cast<int*>(tri_collection.data_ptr()),
            reinterpret_cast<int*>(initial_touch_count.data_ptr()),
            reinterpret_cast<int*>(initial_touch_inds.data_ptr())
        );

        // Compute distortion loss from states
        auto states_reshaped = states.reshape({(long)num_rays, -1});
        auto distortion_pt1 = states_reshaped.select(1, 0);
        auto distortion_pt2 = states_reshaped.select(1, 1);
        auto distortion_loss = distortion_pt1 - distortion_pt2;

        // Combine color and distortion loss
        auto color_and_loss = torch::cat({color, distortion_loss.unsqueeze(1)}, 1);

        // Get initial_inds (filter by count)
        auto initial_count = initial_touch_count.item<int>();
        auto initial_inds = initial_touch_inds.slice(0, 0, initial_count);

        // Save for backward
        ctx->save_for_backward({mean, scale, quat, density, features, rayo, rayd,
                               tri_collection, wcts, initial_drgb, initial_inds,
                               states, diracs, iters_tensor});
        ctx->saved_data["tmin"] = params.tmin;
        ctx->saved_data["tmax"] = params.tmax;
        ctx->saved_data["max_prim_size"] = params.max_prim_size;
        ctx->saved_data["max_iters"] = (int64_t)params.max_iters;

        return {color_and_loss};
    }

    static std::vector<torch::Tensor> backward(
        torch::autograd::AutogradContext* ctx,
        std::vector<torch::Tensor> grad_outputs
    ) {
        auto saved = ctx->get_saved_variables();
        auto mean = saved[0];
        auto scale = saved[1];
        auto quat = saved[2];
        auto density = saved[3];
        auto features = saved[4];
        auto rayo = saved[5];
        auto rayd = saved[6];
        auto tri_collection = saved[7];
        auto wcts = saved[8];
        auto initial_drgb = saved[9];
        auto initial_inds = saved[10];
        auto states = saved[11];
        auto diracs = saved[12];
        auto iters_tensor = saved[13];

        float tmin = ctx->saved_data["tmin"].toDouble();
        float tmax = ctx->saved_data["tmax"].toDouble();
        float max_prim_size = ctx->saved_data["max_prim_size"].toDouble();
        int64_t max_iters = ctx->saved_data["max_iters"].toInt();

        auto device = mean.device();
        auto grad_output = grad_outputs[0].contiguous();
        const size_t num_prims = mean.size(0);
        const size_t num_rays = rayo.size(0);

        // Check if we have any iterations to process
        auto iters_sum = iters_tensor.sum().item<int>();
        if (iters_sum <= 0) {
            // Return zeros
            return {
                torch::zeros_like(mean),
                torch::zeros_like(scale),
                torch::zeros_like(quat),
                torch::zeros_like(density),
                torch::zeros_like(features),
                torch::zeros_like(rayo),
                torch::zeros_like(rayd),
                torch::Tensor(),  // wcts
                torch::Tensor(), torch::Tensor(), torch::Tensor()  // params, optix_context, gas_handle
            };
        }

        // Allocate gradient outputs
        auto dL_dmeans = torch::zeros({(long)num_prims, 3}, torch::dtype(torch::kFloat32).device(device));
        auto dL_dscales = torch::zeros({(long)num_prims, 3}, torch::dtype(torch::kFloat32).device(device));
        auto dL_dquats = torch::zeros({(long)num_prims, 4}, torch::dtype(torch::kFloat32).device(device));
        auto dL_ddensities = torch::zeros({(long)num_prims}, torch::dtype(torch::kFloat32).device(device));
        auto dL_dfeatures = torch::zeros_like(features);
        auto dL_drayo = torch::zeros({(long)num_rays, 3}, torch::dtype(torch::kFloat32).device(device));
        auto dL_drayd = torch::zeros({(long)num_rays, 3}, torch::dtype(torch::kFloat32).device(device));
        auto dL_dmeans2D = torch::zeros({(long)num_prims, 2}, torch::dtype(torch::kFloat32).device(device));
        auto touch_count = torch::zeros({(long)num_prims}, torch::dtype(torch::kInt32).device(device));
        auto dL_dinital_drgb = torch::zeros({(long)num_rays, 4}, torch::dtype(torch::kFloat32).device(device));

        // Create wcts if empty
        auto wcts_use = wcts.numel() > 0 ? wcts : torch::ones({1, 4, 4}, torch::dtype(torch::kFloat32).device(device));

        // Build DualModel
        DualModel model;
        model.means = make_tensor_view(mean);
        model.scales = make_tensor_view(scale);
        model.quats = make_tensor_view(quat);
        model.densities = make_tensor_view(density);
        model.features = make_tensor_view(features);
        model.dL_dmeans = make_tensor_view(dL_dmeans);
        model.dL_dscales = make_tensor_view(dL_dscales);
        model.dL_dquats = make_tensor_view(dL_dquats);
        model.dL_ddensities = make_tensor_view(dL_ddensities);
        model.dL_dfeatures = make_tensor_view(dL_dfeatures);
        model.dL_drayos = make_tensor_view(dL_drayo);
        model.dL_drayds = make_tensor_view(dL_drayd);
        model.dL_dmeans2D = make_tensor_view(dL_dmeans2D);

        cudaStream_t stream = at::cuda::getCurrentCUDAStream();

        // Launch backwards kernel
        launch_backwards_kernel(
            make_tensor_view(states),
            make_tensor_view(diracs),
            make_tensor_view(iters_tensor),
            make_tensor_view(tri_collection),
            make_tensor_view(rayo),
            make_tensor_view(rayd),
            model,
            make_tensor_view(initial_drgb),
            make_tensor_view(dL_dinital_drgb),
            make_tensor_view(touch_count),
            make_tensor_view(grad_output),
            make_tensor_view(wcts_use),
            tmin, tmax, max_prim_size, max_iters,
            num_rays, stream
        );

        // Launch initial drgb kernel if needed
        if (initial_inds.size(0) > 0) {
            launch_backwards_initial_drgb_kernel(
                make_tensor_view(rayo),
                make_tensor_view(rayd),
                model,
                make_tensor_view(initial_drgb),
                make_tensor_view(initial_inds),
                make_tensor_view(dL_dinital_drgb),
                make_tensor_view(touch_count),
                tmin, num_rays, initial_inds.size(0), stream
            );
        }

        // Clamp gradients
        float v = 1e3f;
        float mean_v = 1e3f;
        dL_dmeans = dL_dmeans.clamp(-mean_v, mean_v);
        dL_dscales = dL_dscales.clamp(-v, v);
        dL_dquats = dL_dquats.clamp(-v, v);
        dL_ddensities = dL_ddensities.clamp(-50.0f, 50.0f).reshape_as(density);
        dL_dfeatures = dL_dfeatures.clamp(-v, v);
        dL_drayo = dL_drayo.clamp(-v, v);
        dL_drayd = dL_drayd.clamp(-v, v);

        auto dL_dwcts = wcts.numel() > 0 ? dL_dmeans2D : torch::Tensor();

        return {
            dL_dmeans, dL_dscales, dL_dquats, dL_ddensities, dL_dfeatures,
            dL_drayo, dL_drayd, dL_dwcts,
            torch::Tensor(), torch::Tensor(), torch::Tensor()  // params, optix_context, gas_handle
        };
    }
};

// Simplified API wrapper - exported function
std::vector<torch::Tensor> trace_rays_autograd(
    torch::Tensor mean,
    torch::Tensor scale,
    torch::Tensor quat,
    torch::Tensor density,
    torch::Tensor features,
    torch::Tensor rayo,
    torch::Tensor rayd,
    torch::Tensor wcts,
    float tmin,
    float tmax,
    float max_prim_size,
    int max_iters,
    int64_t optix_context_ptr,
    int64_t gas_handle
) {
    SplineTracerParams params;
    params.tmin = tmin;
    params.tmax = tmax;
    params.max_prim_size = max_prim_size;
    params.max_iters = max_iters;

    return SplineTracerFunction::apply(
        mean, scale, quat, density, features,
        rayo, rayd, wcts, params,
        optix_context_ptr, gas_handle
    );
}
